{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nimport useDebouncedCallback from './useDebouncedCallback';\nfunction valueEquality(left, right) {\n  return left === right;\n}\nexport default function useDebounce(value, delay, options) {\n  var eq = options && options.equalityFn ? options.equalityFn : valueEquality;\n  var _a = useState(value),\n    state = _a[0],\n    dispatch = _a[1];\n  var _b = useDebouncedCallback(useCallback(function (value) {\n      return dispatch(value);\n    }, []), delay, options),\n    callback = _b[0],\n    cancel = _b[1],\n    callPending = _b[2];\n  var previousValue = useRef(value);\n  useEffect(function () {\n    // We need to use this condition otherwise we will run debounce timer for the first render (including maxWait option)\n    if (!eq(previousValue.current, value)) {\n      callback(value);\n      previousValue.current = value;\n    }\n  }, [value, callback, eq]);\n  return [state, cancel, callPending];\n}","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useDebouncedCallback","valueEquality","left","right","useDebounce","value","delay","options","eq","equalityFn","_a","state","dispatch","_b","callback","cancel","callPending","previousValue","current"],"sources":["/Users/willsbball/Desktop/Wilfried/Work/My-Neighborhood/my-neighborhood-front/node_modules/use-debounce/esm/useDebounce.js"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nimport useDebouncedCallback from './useDebouncedCallback';\nfunction valueEquality(left, right) {\n    return left === right;\n}\nexport default function useDebounce(value, delay, options) {\n    var eq = options && options.equalityFn ? options.equalityFn : valueEquality;\n    var _a = useState(value), state = _a[0], dispatch = _a[1];\n    var _b = useDebouncedCallback(useCallback(function (value) { return dispatch(value); }, []), delay, options), callback = _b[0], cancel = _b[1], callPending = _b[2];\n    var previousValue = useRef(value);\n    useEffect(function () {\n        // We need to use this condition otherwise we will run debounce timer for the first render (including maxWait option)\n        if (!eq(previousValue.current, value)) {\n            callback(value);\n            previousValue.current = value;\n        }\n    }, [value, callback, eq]);\n    return [state, cancel, callPending];\n}\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAChE,OAAOC,oBAAoB,MAAM,wBAAwB;AACzD,SAASC,aAAaA,CAACC,IAAI,EAAEC,KAAK,EAAE;EAChC,OAAOD,IAAI,KAAKC,KAAK;AACzB;AACA,eAAe,SAASC,WAAWA,CAACC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAE;EACvD,IAAIC,EAAE,GAAGD,OAAO,IAAIA,OAAO,CAACE,UAAU,GAAGF,OAAO,CAACE,UAAU,GAAGR,aAAa;EAC3E,IAAIS,EAAE,GAAGX,QAAQ,CAACM,KAAK,CAAC;IAAEM,KAAK,GAAGD,EAAE,CAAC,CAAC,CAAC;IAAEE,QAAQ,GAAGF,EAAE,CAAC,CAAC,CAAC;EACzD,IAAIG,EAAE,GAAGb,oBAAoB,CAACJ,WAAW,CAAC,UAAUS,KAAK,EAAE;MAAE,OAAOO,QAAQ,CAACP,KAAK,CAAC;IAAE,CAAC,EAAE,EAAE,CAAC,EAAEC,KAAK,EAAEC,OAAO,CAAC;IAAEO,QAAQ,GAAGD,EAAE,CAAC,CAAC,CAAC;IAAEE,MAAM,GAAGF,EAAE,CAAC,CAAC,CAAC;IAAEG,WAAW,GAAGH,EAAE,CAAC,CAAC,CAAC;EACnK,IAAII,aAAa,GAAGnB,MAAM,CAACO,KAAK,CAAC;EACjCR,SAAS,CAAC,YAAY;IAClB;IACA,IAAI,CAACW,EAAE,CAACS,aAAa,CAACC,OAAO,EAAEb,KAAK,CAAC,EAAE;MACnCS,QAAQ,CAACT,KAAK,CAAC;MACfY,aAAa,CAACC,OAAO,GAAGb,KAAK;IACjC;EACJ,CAAC,EAAE,CAACA,KAAK,EAAES,QAAQ,EAAEN,EAAE,CAAC,CAAC;EACzB,OAAO,CAACG,KAAK,EAAEI,MAAM,EAAEC,WAAW,CAAC;AACvC"},"metadata":{},"sourceType":"module","externalDependencies":[]}