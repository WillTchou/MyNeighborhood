{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nexport default function useDebouncedCallback(callback, delay, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var maxWait = options.maxWait;\n  var maxWaitHandler = useRef(null);\n  var maxWaitArgs = useRef([]);\n  var leading = options.leading;\n  var trailing = options.trailing === undefined ? true : options.trailing;\n  var leadingCall = useRef(false);\n  var functionTimeoutHandler = useRef(null);\n  var isComponentUnmounted = useRef(false);\n  var debouncedFunction = useRef(callback);\n  debouncedFunction.current = callback;\n  var cancelDebouncedCallback = useCallback(function () {\n    clearTimeout(functionTimeoutHandler.current);\n    clearTimeout(maxWaitHandler.current);\n    maxWaitHandler.current = null;\n    maxWaitArgs.current = [];\n    functionTimeoutHandler.current = null;\n    leadingCall.current = false;\n  }, []);\n  useEffect(function () {\n    // We have to set isComponentUnmounted to be truth, as fast-refresh runs all useEffects\n    isComponentUnmounted.current = false;\n    return function () {\n      // we use flag, as we allow to call callPending outside the hook\n      isComponentUnmounted.current = true;\n    };\n  }, []);\n  var debouncedCallback = useCallback(function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    maxWaitArgs.current = args;\n    clearTimeout(functionTimeoutHandler.current);\n    if (leadingCall.current) {\n      leadingCall.current = false;\n    }\n    if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\n      debouncedFunction.current.apply(debouncedFunction, args);\n      leadingCall.current = true;\n    }\n    functionTimeoutHandler.current = setTimeout(function () {\n      var shouldCallFunction = true;\n      if (leading && leadingCall.current) {\n        shouldCallFunction = false;\n      }\n      cancelDebouncedCallback();\n      if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\n        debouncedFunction.current.apply(debouncedFunction, args);\n      }\n    }, delay);\n    if (maxWait && !maxWaitHandler.current && trailing) {\n      maxWaitHandler.current = setTimeout(function () {\n        var args = maxWaitArgs.current;\n        cancelDebouncedCallback();\n        if (!isComponentUnmounted.current) {\n          debouncedFunction.current.apply(null, args);\n        }\n      }, maxWait);\n    }\n  }, [maxWait, delay, cancelDebouncedCallback, leading, trailing]);\n  var callPending = useCallback(function () {\n    // Call pending callback only if we have anything in our queue\n    if (!functionTimeoutHandler.current) {\n      return;\n    }\n    debouncedFunction.current.apply(null, maxWaitArgs.current);\n    cancelDebouncedCallback();\n  }, [cancelDebouncedCallback]);\n  // At the moment, we use 3 args array so that we save backward compatibility\n  return [debouncedCallback, cancelDebouncedCallback, callPending];\n}","map":{"version":3,"names":["useRef","useCallback","useEffect","useDebouncedCallback","callback","delay","options","maxWait","maxWaitHandler","maxWaitArgs","leading","trailing","undefined","leadingCall","functionTimeoutHandler","isComponentUnmounted","debouncedFunction","current","cancelDebouncedCallback","clearTimeout","debouncedCallback","args","_i","arguments","length","apply","setTimeout","shouldCallFunction","callPending"],"sources":["/Users/willsbball/Desktop/Wilfried/Work/My-Neighborhood/my-neighborhood-front/node_modules/use-debounce/esm/useDebouncedCallback.js"],"sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\nexport default function useDebouncedCallback(callback, delay, options) {\n    if (options === void 0) { options = {}; }\n    var maxWait = options.maxWait;\n    var maxWaitHandler = useRef(null);\n    var maxWaitArgs = useRef([]);\n    var leading = options.leading;\n    var trailing = options.trailing === undefined ? true : options.trailing;\n    var leadingCall = useRef(false);\n    var functionTimeoutHandler = useRef(null);\n    var isComponentUnmounted = useRef(false);\n    var debouncedFunction = useRef(callback);\n    debouncedFunction.current = callback;\n    var cancelDebouncedCallback = useCallback(function () {\n        clearTimeout(functionTimeoutHandler.current);\n        clearTimeout(maxWaitHandler.current);\n        maxWaitHandler.current = null;\n        maxWaitArgs.current = [];\n        functionTimeoutHandler.current = null;\n        leadingCall.current = false;\n    }, []);\n    useEffect(function () {\n        // We have to set isComponentUnmounted to be truth, as fast-refresh runs all useEffects\n        isComponentUnmounted.current = false;\n        return function () {\n            // we use flag, as we allow to call callPending outside the hook\n            isComponentUnmounted.current = true;\n        };\n    }, []);\n    var debouncedCallback = useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        maxWaitArgs.current = args;\n        clearTimeout(functionTimeoutHandler.current);\n        if (leadingCall.current) {\n            leadingCall.current = false;\n        }\n        if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\n            debouncedFunction.current.apply(debouncedFunction, args);\n            leadingCall.current = true;\n        }\n        functionTimeoutHandler.current = setTimeout(function () {\n            var shouldCallFunction = true;\n            if (leading && leadingCall.current) {\n                shouldCallFunction = false;\n            }\n            cancelDebouncedCallback();\n            if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\n                debouncedFunction.current.apply(debouncedFunction, args);\n            }\n        }, delay);\n        if (maxWait && !maxWaitHandler.current && trailing) {\n            maxWaitHandler.current = setTimeout(function () {\n                var args = maxWaitArgs.current;\n                cancelDebouncedCallback();\n                if (!isComponentUnmounted.current) {\n                    debouncedFunction.current.apply(null, args);\n                }\n            }, maxWait);\n        }\n    }, [maxWait, delay, cancelDebouncedCallback, leading, trailing]);\n    var callPending = useCallback(function () {\n        // Call pending callback only if we have anything in our queue\n        if (!functionTimeoutHandler.current) {\n            return;\n        }\n        debouncedFunction.current.apply(null, maxWaitArgs.current);\n        cancelDebouncedCallback();\n    }, [cancelDebouncedCallback]);\n    // At the moment, we use 3 args array so that we save backward compatibility\n    return [debouncedCallback, cancelDebouncedCallback, callPending];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}